const RETRIES = 3; // Initial attempt + 3 retries = 4 total attempts
const INITIAL_RETRY_DELAY = 1000; // 1 second

export const generateText = async (prompt: string): Promise<string> => {
  const encodedPrompt = encodeURIComponent(prompt);
  // Using a CORS proxy to prevent "Failed to fetch" errors in the browser when calling the API from the client-side.
  const url = `https://corsproxy.io/?https://text.pollinations.ai/${encodedPrompt}`;
  let lastError: Error | null = null;
  let isRateLimitError = false;

  for (let i = 0; i <= RETRIES; i++) {
    try {
      // The API is called via a simple GET request
      const response = await fetch(url);

      if (response.ok) {
        const text = await response.text();
        let aiText = '';
        // The API returns a JSON object: {"text": "..."}
        try {
          const data = JSON.parse(text);
          aiText = data.text || 'Could not parse AI response.';
        } catch (e) {
          // Fallback if the response is not valid JSON, but just plain text
          aiText = text || 'Received an empty response from AI.';
        }

        // Remove known watermarks from the AI's response
        return aiText.replace(/---\s*Generated by Pollinations\.ai/gi, '').trim();
      }

      // Check for specific error types
      if (response.status === 429) {
        isRateLimitError = true;
        lastError = new Error(`Rate limit exceeded: ${response.status} ${response.statusText}`);
      } else if (response.status >= 400 && response.status < 500) {
        // For other client errors (like 400), don't retry.
        lastError = new Error(`Client Error: ${response.status} ${response.statusText}`);
        break;
      } else {
        // For server errors (5xx) or other issues, retry is appropriate.
        lastError = new Error(`Network response was not ok: ${response.status} ${response.statusText}`);
      }


      if (i < RETRIES) {
        const delay = INITIAL_RETRY_DELAY * Math.pow(2, i);
        console.warn(`Attempt ${i + 1} failed. Retrying in ${delay}ms...`);
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    } catch (error) {
      lastError = error instanceof Error ? error : new Error(String(error));
      if (i < RETRIES) {
        const delay = INITIAL_RETRY_DELAY * Math.pow(2, i);
        console.warn(`Attempt ${i + 1} failed with a network error. Retrying in ${delay}ms...`);
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
  }
  
  console.error("Error fetching text from Pollinations AI after multiple retries:", lastError);
  if (isRateLimitError) {
      return "The AI service is currently busy due to high demand. Please wait a moment and try your request again.";
  }
  return "Sorry, I couldn't generate a response. The AI service seems to be unavailable right now. Please try again later.";
};

export const generateImageUrl = (prompt: string, model: string = 'flux', aspectRatio: string = '1:1'): string => {
    const encodedPrompt = encodeURIComponent(prompt);
    // Using seed to get different images and as a cache buster
    const seed = Math.floor(Math.random() * 1000000); 

    let width = 1024;
    let height = 1024;

    switch (aspectRatio) {
        case '16:9':
            width = 1280;
            height = 720;
            break;
        case '9:16':
            width = 720;
            height = 1280;
            break;
        case '4:3':
            width = 1024;
            height = 768;
            break;
        case '3:4':
            width = 768;
            height = 1024;
            break;
        case '1:1':
        default:
            width = 1024;
            height = 1024;
            break;
    }

    // Request high-resolution images, use a better model, and attempt to remove watermarks.
    return `https://image.pollinations.ai/prompt/${encodedPrompt}?width=${width}&height=${height}&seed=${seed}&model=${model}&nofeed=true&nolove=true`;
};
